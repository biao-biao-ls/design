# ğŸ“• KNZN å•†ä¸šåŒ–ä¸åˆè§„æŒ‡å— (Business)

> **æ ¸å¿ƒç›®æ ‡**: å…¨çƒå¸‚åœºåˆè§„ + è‡ªåŠ¨åŒ–å•†ä¸šåŒ– - Lemon Squeezy æ”¯ä»˜ + GDPR åˆè§„ + SEO ä¼˜åŒ–

## ğŸ“‹ æ–‡æ¡£æ¦‚è¿°

**å•†ä¸šæ¨¡å¼**: SaaS è®¢é˜… + è”ç›Ÿè¥é”€  
**åˆè§„è¦æ±‚**: GDPR/CCPA + å…¨çƒç¨åŠ¡è‡ªåŠ¨åŒ–  
**è¥é”€ç­–ç•¥**: SEO + å†…å®¹è¥é”€ + ç¤¾åŒºé©±åŠ¨  
**æ–‡æ¡£ç‰ˆæœ¬**: v2.0 (KNZN ä¸“ç”¨ç‰ˆ)  

## ğŸ’³ æ”¯ä»˜ç³»ç»Ÿ (Lemon Squeezy)

### å•†ä¸šåŒ–æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å…¨çƒç”¨æˆ·æ”¯ä»˜                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ‡ºğŸ‡¸ USD â”‚ ğŸ‡ªğŸ‡º EUR â”‚ ğŸ‡¬ğŸ‡§ GBP â”‚ ğŸ‡¯ğŸ‡µ JPY â”‚ ğŸ‡¦ğŸ‡º AUD            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Lemon Squeezy æ”¯ä»˜ç½‘å…³                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â€¢ è‡ªåŠ¨ç¨åŠ¡å¤„ç† (VAT/GST/Sales Tax)                             â”‚
â”‚ â€¢ å¤šå¸ç§æ”¯æŒ (150+ å›½å®¶)                                       â”‚
â”‚ â€¢ æ¬ºè¯ˆæ£€æµ‹å’Œé£é™©ç®¡ç†                                            â”‚
â”‚ â€¢ è‡ªåŠ¨å‘ç¥¨ç”Ÿæˆ                                                  â”‚
â”‚ â€¢ é€€æ¬¾å’Œäº‰è®®å¤„ç†                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                â”‚
                                â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      KNZN è®¢é˜…ç®¡ç†                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Webhook å¤„ç†        â”‚ ç”¨æˆ·æƒé™åŒæ­¥      â”‚ ä½¿ç”¨é‡è·Ÿè¸ª              â”‚
â”‚ â€¢ è®¢é˜…åˆ›å»º          â”‚ â€¢ Pro æƒé™å¼€é€š    â”‚ â€¢ API è°ƒç”¨é™åˆ¶          â”‚
â”‚ â€¢ è®¢é˜…æ›´æ–°          â”‚ â€¢ åŠŸèƒ½è§£é”        â”‚ â€¢ å­˜å‚¨é…é¢              â”‚
â”‚ â€¢ è®¢é˜…å–æ¶ˆ          â”‚ â€¢ é™çº§å¤„ç†        â”‚ â€¢ é‚®ä»¶å‘é€é™åˆ¶          â”‚
â”‚ â€¢ æ”¯ä»˜å¤±è´¥          â”‚ â€¢ å®½é™æœŸç®¡ç†      â”‚ â€¢ ä¼˜å…ˆæ”¯æŒ              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¢é˜…è®¡åˆ’é…ç½®

```typescript
// shared/types/subscription.ts
export interface SubscriptionPlan {
  id: string
  name: string
  price: number
  currency: string
  interval: 'month' | 'year'
  features: PlanFeature[]
  limits: PlanLimits
  popular?: boolean
}

export interface PlanFeature {
  name: string
  description: string
  included: boolean
  limit?: number
}

export interface PlanLimits {
  simulationTime: number // åˆ†é’Ÿ/æœˆ
  storageQuota: number // MB
  aiQueries: number // æ¬¡/æœˆ
  emailSupport: boolean
  prioritySupport: boolean
  certificateDownloads: number
  blueprintAccess: 'basic' | 'premium' | 'all'
}

// è®¢é˜…è®¡åˆ’å®šä¹‰
export const SUBSCRIPTION_PLANS: SubscriptionPlan[] = [
  {
    id: 'free',
    name: 'Free',
    price: 0,
    currency: 'USD',
    interval: 'month',
    features: [
      { name: 'Basic Simulations', description: '30 minutes per month', included: true, limit: 30 },
      { name: 'Community Access', description: 'Join discussions and share projects', included: true },
      { name: 'Basic Blueprints', description: 'Access to 20+ free blueprints', included: true },
      { name: 'Email Support', description: 'Community support only', included: false },
      { name: 'Certificates', description: 'Basic completion certificates', included: true, limit: 3 }
    ],
    limits: {
      simulationTime: 30,
      storageQuota: 100,
      aiQueries: 10,
      emailSupport: false,
      prioritySupport: false,
      certificateDownloads: 3,
      blueprintAccess: 'basic'
    }
  },
  {
    id: 'pro-monthly',
    name: 'Pro',
    price: 9.99,
    currency: 'USD',
    interval: 'month',
    popular: true,
    features: [
      { name: 'Unlimited Simulations', description: 'No time limits', included: true },
      { name: 'Premium Blueprints', description: 'Access to 200+ premium blueprints', included: true },
      { name: 'AI Debugging Assistant', description: 'Unlimited AI-powered help', included: true },
      { name: 'Priority Support', description: '24h email response time', included: true },
      { name: 'LinkedIn Certificates', description: 'Professional certificates with LinkedIn integration', included: true },
      { name: 'Advanced Analytics', description: 'Detailed learning progress tracking', included: true }
    ],
    limits: {
      simulationTime: -1, // æ— é™åˆ¶
      storageQuota: 1000,
      aiQueries: -1,
      emailSupport: true,
      prioritySupport: true,
      certificateDownloads: -1,
      blueprintAccess: 'all'
    }
  },
  {
    id: 'pro-yearly',
    name: 'Pro (Yearly)',
    price: 99.99,
    currency: 'USD',
    interval: 'year',
    features: [
      { name: 'All Pro Features', description: 'Everything in Pro plan', included: true },
      { name: '2 Months Free', description: 'Save 17% with annual billing', included: true },
      { name: 'Early Access', description: 'Beta features and new content first', included: true }
    ],
    limits: {
      simulationTime: -1,
      storageQuota: 2000,
      aiQueries: -1,
      emailSupport: true,
      prioritySupport: true,
      certificateDownloads: -1,
      blueprintAccess: 'all'
    }
  }
]
```

### Lemon Squeezy é›†æˆ

```typescript
// server/api/payment/create-checkout.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { planId, userId, email } = body
  
  // ğŸ” éªŒè¯ç”¨æˆ·
  const session = await getUserSession(event)
  if (!session || session.user.id !== userId) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    })
  }
  
  // ğŸ“‹ è·å–è®¡åˆ’ä¿¡æ¯
  const plan = SUBSCRIPTION_PLANS.find(p => p.id === planId)
  if (!plan || plan.price === 0) {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid plan'
    })
  }
  
  try {
    // ğŸ›’ åˆ›å»º Lemon Squeezy ç»“è´¦ä¼šè¯
    const checkoutResponse = await fetch('https://api.lemonsqueezy.com/v1/checkouts', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.LEMON_SQUEEZY_API_KEY}`,
        'Content-Type': 'application/vnd.api+json',
        'Accept': 'application/vnd.api+json'
      },
      body: JSON.stringify({
        data: {
          type: 'checkouts',
          attributes: {
            checkout_data: {
              email: email,
              name: session.user.name,
              custom: {
                user_id: userId
              }
            }
          },
          relationships: {
            store: {
              data: {
                type: 'stores',
                id: process.env.LEMON_SQUEEZY_STORE_ID
              }
            },
            variant: {
              data: {
                type: 'variants',
                id: getVariantId(planId) // æ˜ å°„åˆ° Lemon Squeezy äº§å“å˜ä½“
              }
            }
          }
        }
      })
    })
    
    if (!checkoutResponse.ok) {
      throw new Error('Failed to create checkout session')
    }
    
    const checkout = await checkoutResponse.json()
    
    // ğŸ“ è®°å½•ç»“è´¦ä¼šè¯
    await db.insert(checkoutSessions).values({
      id: nanoid(),
      userId,
      planId,
      lemonSqueezyCheckoutId: checkout.data.id,
      status: 'pending',
      createdAt: new Date()
    })
    
    return {
      checkoutUrl: checkout.data.attributes.url,
      checkoutId: checkout.data.id
    }
  } catch (error) {
    console.error('Checkout creation error:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Failed to create checkout session'
    })
  }
})

// ğŸ—ºï¸ è®¡åˆ’ ID åˆ° Lemon Squeezy å˜ä½“ ID çš„æ˜ å°„
const getVariantId = (planId: string): string => {
  const variantMap: Record<string, string> = {
    'pro-monthly': process.env.LEMON_SQUEEZY_PRO_MONTHLY_VARIANT_ID!,
    'pro-yearly': process.env.LEMON_SQUEEZY_PRO_YEARLY_VARIANT_ID!
  }
  
  return variantMap[planId] || ''
}
```

### è®¢é˜…çŠ¶æ€ç®¡ç†

```typescript
// server/api/webhook/lemon-squeezy.post.ts
import crypto from 'crypto'

export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const signature = getHeader(event, 'x-signature')
  
  // ğŸ” éªŒè¯ Webhook ç­¾å
  const expectedSignature = crypto
    .createHmac('sha256', process.env.LEMON_SQUEEZY_WEBHOOK_SECRET!)
    .update(JSON.stringify(body))
    .digest('hex')
  
  if (signature !== expectedSignature) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Invalid webhook signature'
    })
  }
  
  const { event_name, data } = body
  
  try {
    switch (event_name) {
      case 'subscription_created':
        await handleSubscriptionCreated(data)
        break
      case 'subscription_updated':
        await handleSubscriptionUpdated(data)
        break
      case 'subscription_cancelled':
        await handleSubscriptionCancelled(data)
        break
      case 'subscription_resumed':
        await handleSubscriptionResumed(data)
        break
      case 'subscription_expired':
        await handleSubscriptionExpired(data)
        break
      case 'subscription_payment_failed':
        await handlePaymentFailed(data)
        break
      case 'subscription_payment_success':
        await handlePaymentSuccess(data)
        break
    }
    
    return { success: true }
  } catch (error) {
    console.error('Webhook processing error:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Webhook processing failed'
    })
  }
})

// ğŸ¯ è®¢é˜…åˆ›å»ºå¤„ç†
const handleSubscriptionCreated = async (data: any) => {
  const { customer_email, status, product_name, variant_name, custom_data } = data.attributes
  const userId = custom_data?.user_id
  
  if (!userId) {
    console.error('No user ID in subscription data')
    return
  }
  
  // âœ… æ¿€æ´» Pro æƒé™
  await db.update(users)
    .set({
      isPro: true,
      proSubscriptionStatus: status,
      proSubscriptionPlan: variant_name,
      proActivatedAt: new Date(),
      proExpiresAt: new Date(data.attributes.renews_at)
    })
    .where(eq(users.id, userId))
  
  // ğŸ“ è®°å½•è®¢é˜…
  await db.insert(subscriptions).values({
    id: nanoid(),
    userId,
    lemonSqueezyId: data.id,
    status,
    planName: variant_name,
    price: data.attributes.unit_price,
    currency: data.attributes.currency,
    renewsAt: new Date(data.attributes.renews_at),
    createdAt: new Date()
  })
  
  // ğŸ“§ å‘é€æ¬¢è¿é‚®ä»¶
  await sendEmail({
    to: customer_email,
    template: 'pro-welcome',
    data: {
      planName: variant_name,
      features: getProFeatures()
    }
  })
  
  console.log(`âœ… Pro subscription activated for user: ${userId}`)
}

// ğŸ”„ è®¢é˜…æ›´æ–°å¤„ç†
const handleSubscriptionUpdated = async (data: any) => {
  const { custom_data, status, renews_at } = data.attributes
  const userId = custom_data?.user_id
  
  if (!userId) return
  
  await db.update(users)
    .set({
      proSubscriptionStatus: status,
      proExpiresAt: new Date(renews_at)
    })
    .where(eq(users.id, userId))
  
  await db.update(subscriptions)
    .set({
      status,
      renewsAt: new Date(renews_at),
      updatedAt: new Date()
    })
    .where(eq(subscriptions.lemonSqueezyId, data.id))
}

// âŒ è®¢é˜…å–æ¶ˆå¤„ç†
const handleSubscriptionCancelled = async (data: any) => {
  const { custom_data, ends_at } = data.attributes
  const userId = custom_data?.user_id
  
  if (!userId) return
  
  // ğŸ• è®¾ç½®å®½é™æœŸ (è®¢é˜…åˆ°æœŸå‰ä¿æŒ Pro æƒé™)
  await db.update(users)
    .set({
      proSubscriptionStatus: 'cancelled',
      proExpiresAt: new Date(ends_at) // ä¿æŒåˆ°æœŸæœ«
    })
    .where(eq(users.id, userId))
  
  // ğŸ“§ å‘é€å–æ¶ˆç¡®è®¤é‚®ä»¶
  const user = await db.select().from(users).where(eq(users.id, userId)).limit(1)
  if (user.length) {
    await sendEmail({
      to: user[0].email,
      template: 'subscription-cancelled',
      data: {
        name: user[0].name,
        expiresAt: ends_at,
        reactivateUrl: 'https://knzn.net/pricing'
      }
    })
  }
  
  console.log(`âŒ Subscription cancelled for user: ${userId}, expires: ${ends_at}`)
}

// â° è®¢é˜…è¿‡æœŸå¤„ç†
const handleSubscriptionExpired = async (data: any) => {
  const { custom_data } = data.attributes
  const userId = custom_data?.user_id
  
  if (!userId) return
  
  // ğŸ”’ ç§»é™¤ Pro æƒé™
  await db.update(users)
    .set({
      isPro: false,
      proSubscriptionStatus: 'expired',
      proExpiredAt: new Date()
    })
    .where(eq(users.id, userId))
  
  // ğŸ“§ å‘é€ç»­è´¹æé†’
  const user = await db.select().from(users).where(eq(users.id, userId)).limit(1)
  if (user.length) {
    await sendEmail({
      to: user[0].email,
      template: 'subscription-expired',
      data: {
        name: user[0].name,
        renewUrl: 'https://knzn.net/pricing'
      }
    })
  }
  
  console.log(`â° Subscription expired for user: ${userId}`)
}
```

## ğŸ›¡ï¸ GDPR åˆè§„ç³»ç»Ÿ

### Cookie åŒæ„ç®¡ç†

```vue
<!-- components/CookieConsentBanner.vue -->
<template>
  <div v-if="showBanner" class="cookie-consent-banner">
    <div class="banner-content">
      <div class="banner-text">
        <h3>ğŸª We use cookies</h3>
        <p>
          We use cookies to enhance your experience, analyze site usage, and assist with marketing efforts. 
          <a href="/privacy-policy" target="_blank">Learn more</a>
        </p>
      </div>
      
      <div class="cookie-categories">
        <div 
          v-for="category in cookieCategories"
          :key="category.id"
          class="category-item"
        >
          <label class="category-label">
            <input 
              type="checkbox" 
              v-model="category.accepted"
              :disabled="category.required"
              class="category-checkbox"
            />
            <span class="category-name">{{ category.name }}</span>
          </label>
          <p class="category-description">{{ category.description }}</p>
        </div>
      </div>
      
      <div class="banner-actions">
        <button @click="acceptAll" class="btn-accept-all">
          Accept All
        </button>
        <button @click="acceptSelected" class="btn-accept-selected">
          Accept Selected
        </button>
        <button @click="rejectAll" class="btn-reject">
          Reject All
        </button>
        <button @click="showSettings = true" class="btn-settings">
          Settings
        </button>
      </div>
    </div>
    
    <!-- ğŸ”§ è¯¦ç»†è®¾ç½®é¢æ¿ -->
    <div v-if="showSettings" class="settings-panel">
      <div class="settings-header">
        <h3>Cookie Settings</h3>
        <button @click="showSettings = false" class="close-btn">Ã—</button>
      </div>
      
      <div class="settings-content">
        <div 
          v-for="category in cookieCategories"
          :key="category.id"
          class="setting-category"
        >
          <div class="category-header">
            <label class="toggle-label">
              <input 
                type="checkbox" 
                v-model="category.accepted"
                :disabled="category.required"
                class="toggle-input"
              />
              <span class="toggle-slider"></span>
              <span class="category-title">{{ category.name }}</span>
            </label>
          </div>
          
          <p class="category-detail">{{ category.description }}</p>
          
          <div class="cookie-list">
            <h4>Cookies used:</h4>
            <ul>
              <li v-for="cookie in category.cookies" :key="cookie">
                <code>{{ cookie }}</code>
              </li>
            </ul>
          </div>
        </div>
      </div>
      
      <div class="settings-actions">
        <button @click="saveSettings" class="btn-save">Save Settings</button>
        <button @click="showSettings = false" class="btn-cancel">Cancel</button>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
interface CookieCategory {
  id: string
  name: string
  description: string
  required: boolean
  accepted: boolean
  cookies: string[]
}

const showBanner = ref(false)
const showSettings = ref(false)

// ğŸª Cookie åˆ†ç±»å®šä¹‰
const cookieCategories = ref<CookieCategory[]>([
  {
    id: 'necessary',
    name: 'Strictly Necessary',
    description: 'These cookies are essential for the website to function properly. They cannot be disabled.',
    required: true,
    accepted: true,
    cookies: ['session_token', 'csrf_token', 'auth_state', 'cookie_consent']
  },
  {
    id: 'functional',
    name: 'Functional',
    description: 'These cookies enable enhanced functionality and personalization, such as remembering your preferences.',
    required: false,
    accepted: false,
    cookies: ['user_preferences', 'theme_setting', 'language_setting']
  },
  {
    id: 'analytics',
    name: 'Analytics',
    description: 'These cookies help us understand how visitors interact with our website by collecting anonymous information.',
    required: false,
    accepted: false,
    cookies: ['_ga', '_gid', '_gat', 'analytics_session']
  },
  {
    id: 'marketing',
    name: 'Marketing',
    description: 'These cookies are used to track visitors across websites to display relevant advertisements.',
    required: false,
    accepted: false,
    cookies: ['marketing_id', 'ad_tracking', 'conversion_pixel']
  }
])

// ğŸ” æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºæ¨ªå¹…
const checkConsentStatus = () => {
  const consent = localStorage.getItem('cookie_consent')
  if (!consent) {
    showBanner.value = true
  } else {
    const consentData = JSON.parse(consent)
    cookieCategories.value.forEach(category => {
      if (!category.required) {
        category.accepted = consentData[category.id] || false
      }
    })
    applyConsentSettings()
  }
}

// âœ… æ¥å—æ‰€æœ‰ Cookie
const acceptAll = () => {
  cookieCategories.value.forEach(category => {
    category.accepted = true
  })
  saveConsentSettings()
  showBanner.value = false
}

// ğŸ¯ æ¥å—é€‰ä¸­çš„ Cookie
const acceptSelected = () => {
  saveConsentSettings()
  showBanner.value = false
}

// âŒ æ‹’ç»æ‰€æœ‰éå¿…éœ€ Cookie
const rejectAll = () => {
  cookieCategories.value.forEach(category => {
    if (!category.required) {
      category.accepted = false
    }
  })
  saveConsentSettings()
  showBanner.value = false
}

// ğŸ’¾ ä¿å­˜è®¾ç½®
const saveSettings = () => {
  saveConsentSettings()
  showSettings.value = false
  showBanner.value = false
}

// ğŸ’¾ ä¿å­˜åŒæ„è®¾ç½®
const saveConsentSettings = () => {
  const consentData: Record<string, boolean> = {}
  cookieCategories.value.forEach(category => {
    consentData[category.id] = category.accepted
  })
  
  localStorage.setItem('cookie_consent', JSON.stringify(consentData))
  localStorage.setItem('cookie_consent_date', new Date().toISOString())
  
  applyConsentSettings()
}

// ğŸ”§ åº”ç”¨åŒæ„è®¾ç½®
const applyConsentSettings = () => {
  cookieCategories.value.forEach(category => {
    if (category.accepted) {
      enableCookieCategory(category.id)
    } else {
      disableCookieCategory(category.id)
    }
  })
}

// âœ… å¯ç”¨ Cookie ç±»åˆ«
const enableCookieCategory = (categoryId: string) => {
  switch (categoryId) {
    case 'analytics':
      // å¯ç”¨ Google Analytics
      if (typeof gtag !== 'undefined') {
        gtag('consent', 'update', {
          'analytics_storage': 'granted'
        })
      }
      break
    case 'marketing':
      // å¯ç”¨è¥é”€ Cookie
      if (typeof gtag !== 'undefined') {
        gtag('consent', 'update', {
          'ad_storage': 'granted',
          'ad_user_data': 'granted',
          'ad_personalization': 'granted'
        })
      }
      break
  }
}

// âŒ ç¦ç”¨ Cookie ç±»åˆ«
const disableCookieCategory = (categoryId: string) => {
  switch (categoryId) {
    case 'analytics':
      if (typeof gtag !== 'undefined') {
        gtag('consent', 'update', {
          'analytics_storage': 'denied'
        })
      }
      break
    case 'marketing':
      if (typeof gtag !== 'undefined') {
        gtag('consent', 'update', {
          'ad_storage': 'denied',
          'ad_user_data': 'denied',
          'ad_personalization': 'denied'
        })
      }
      break
  }
}

onMounted(() => {
  checkConsentStatus()
})
</script>
### ç”¨æˆ·æ•°æ®æƒåˆ©å®ç°

```typescript
// server/api/privacy/export-data.post.ts
export default defineEventHandler(async (event) => {
  const session = await getUserSession(event)
  if (!session) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Authentication required'
    })
  }
  
  const userId = session.user.id
  
  try {
    // ğŸ“Š æ”¶é›†ç”¨æˆ·æ‰€æœ‰æ•°æ®
    const userData = {
      // ğŸ‘¤ åŸºæœ¬ä¿¡æ¯
      profile: await db.select({
        id: users.id,
        name: users.name,
        email: users.email,
        avatarUrl: users.avatarUrl,
        level: users.level,
        xp: users.xp,
        isPro: users.isPro,
        createdAt: users.createdAt,
        lastActiveAt: users.lastActiveAt
      }).from(users).where(eq(users.id, userId)),
      
      // ğŸ“š å­¦ä¹ è¿›åº¦
      progress: await db.select().from(progress).where(eq(progress.userId, userId)),
      
      // ğŸ† è¯ä¹¦è®°å½•
      certificates: await db.select().from(certificates).where(eq(certificates.userId, userId)),
      
      // ğŸ’¬ ç¤¾åŒºå†…å®¹
      posts: await db.select().from(communityPosts).where(eq(communityPosts.userId, userId)),
      
      // ğŸ’³ è®¢é˜…ä¿¡æ¯
      subscriptions: await db.select().from(subscriptions).where(eq(subscriptions.userId, userId)),
      
      // ğŸ“§ é‚®ä»¶è®°å½• (æœ€è¿‘ 90 å¤©)
      emailLogs: await db.select().from(emailLogs)
        .where(and(
          eq(emailLogs.userId, userId),
          gte(emailLogs.createdAt, new Date(Date.now() - 90 * 24 * 60 * 60 * 1000))
        )),
      
      // ğŸ” ç™»å½•è®°å½• (æœ€è¿‘ 30 å¤©)
      loginHistory: await db.select().from(loginHistory)
        .where(and(
          eq(loginHistory.userId, userId),
          gte(loginHistory.createdAt, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))
        ))
    }
    
    // ğŸ“„ ç”Ÿæˆå¯¼å‡ºæ–‡ä»¶
    const exportData = {
      exportedAt: new Date().toISOString(),
      userId,
      dataTypes: Object.keys(userData),
      data: userData,
      metadata: {
        totalRecords: Object.values(userData).flat().length,
        exportFormat: 'JSON',
        gdprCompliant: true
      }
    }
    
    // ğŸ“ è®°å½•å¯¼å‡ºè¯·æ±‚
    await db.insert(dataExportLogs).values({
      id: nanoid(),
      userId,
      exportType: 'full',
      recordCount: exportData.metadata.totalRecords,
      createdAt: new Date()
    })
    
    return {
      success: true,
      data: exportData,
      downloadUrl: await generateExportDownloadUrl(exportData)
    }
  } catch (error) {
    console.error('Data export error:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Data export failed'
    })
  }
})

// ğŸ—‘ï¸ ç”¨æˆ·æ•°æ®åˆ é™¤ API
// server/api/privacy/delete-account.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { confirmationCode, reason } = body
  
  const session = await getUserSession(event)
  if (!session) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Authentication required'
    })
  }
  
  // âœ… éªŒè¯ç¡®è®¤ç 
  if (confirmationCode !== 'DELETE_MY_ACCOUNT') {
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid confirmation code'
    })
  }
  
  const userId = session.user.id
  
  try {
    // ğŸ“Š æ•°æ®åˆ é™¤å‰ç»Ÿè®¡
    const deletionStats = {
      progressRecords: await db.select({ count: count() }).from(progress).where(eq(progress.userId, userId)),
      certificates: await db.select({ count: count() }).from(certificates).where(eq(certificates.userId, userId)),
      posts: await db.select({ count: count() }).from(communityPosts).where(eq(communityPosts.userId, userId))
    }
    
    // ğŸ—‘ï¸ åˆ é™¤å…³è”æ•°æ® (çº§è”åˆ é™¤)
    await db.transaction(async (tx) => {
      // åˆ é™¤å­¦ä¹ è¿›åº¦
      await tx.delete(progress).where(eq(progress.userId, userId))
      
      // åˆ é™¤è¯ä¹¦
      await tx.delete(certificates).where(eq(certificates.userId, userId))
      
      // åŒ¿ååŒ–ç¤¾åŒºå†…å®¹ (ä¿ç•™å†…å®¹ä½†ç§»é™¤ä¸ªäººä¿¡æ¯)
      await tx.update(communityPosts)
        .set({
          userId: 'deleted-user',
          title: '[Deleted User Post]',
          content: '[This content has been removed at the user\'s request]'
        })
        .where(eq(communityPosts.userId, userId))
      
      // åˆ é™¤è®¢é˜…è®°å½•
      await tx.delete(subscriptions).where(eq(subscriptions.userId, userId))
      
      // åˆ é™¤é‚®ä»¶æ—¥å¿—
      await tx.delete(emailLogs).where(eq(emailLogs.userId, userId))
      
      // åˆ é™¤ç™»å½•å†å²
      await tx.delete(loginHistory).where(eq(loginHistory.userId, userId))
      
      // æœ€ååˆ é™¤ç”¨æˆ·è´¦æˆ·
      await tx.delete(users).where(eq(users.id, userId))
    })
    
    // ğŸ“ è®°å½•åˆ é™¤æ—¥å¿— (åŒ¿å)
    await db.insert(accountDeletionLogs).values({
      id: nanoid(),
      deletedUserId: userId, // ä¿ç•™ ID ç”¨äºå®¡è®¡
      reason: reason || 'User request',
      deletionStats: JSON.stringify(deletionStats),
      deletedAt: new Date()
    })
    
    // ğŸ“§ å‘é€åˆ é™¤ç¡®è®¤é‚®ä»¶
    await sendEmail({
      to: session.user.email,
      template: 'account-deleted',
      data: {
        name: session.user.name,
        deletedAt: new Date().toISOString()
      }
    })
    
    // ğŸšª æ¸…é™¤ä¼šè¯
    await clearUserSession(event)
    
    return {
      success: true,
      message: 'Account deleted successfully',
      deletedAt: new Date().toISOString()
    }
  } catch (error) {
    console.error('Account deletion error:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Account deletion failed'
    })
  }
})
```

## ğŸ” SEO ä¼˜åŒ–ç³»ç»Ÿ

### Nuxt SEO é…ç½®

```typescript
// nuxt.config.ts - SEO é…ç½®
export default defineNuxtConfig({
  // ğŸ” SEO æ¨¡å—
  modules: [
    '@nuxtjs/seo'
  ],
  
  // ğŸŒ ç«™ç‚¹é…ç½®
  site: {
    url: 'https://knzn.net',
    name: 'KNZN - Hardware Learning Platform',
    description: 'Learn hardware engineering through interactive simulations and gamified experiences. Master electronics with Wokwi simulations, earn certificates, and join a global community.',
    defaultLocale: 'en'
  },
  
  // ğŸ” SEO é…ç½®
  seo: {
    redirectToCanonicalSiteUrl: true
  },
  
  // ğŸ—ºï¸ Sitemap é…ç½®
  sitemap: {
    hostname: 'https://knzn.net',
    gzip: true,
    routes: async () => {
      // åŠ¨æ€ç”Ÿæˆè·¯ç”±
      const routes = []
      
      // æ·»åŠ è“å›¾é¡µé¢
      const blueprints = await db.select({ id: blueprints.id })
        .from(blueprints)
        .where(eq(blueprints.status, 'published'))
      
      blueprints.forEach(blueprint => {
        routes.push(`/blueprints/${blueprint.id}`)
      })
      
      // æ·»åŠ ç¤¾åŒºå¸–å­
      const posts = await db.select({ id: communityPosts.id })
        .from(communityPosts)
        .where(eq(communityPosts.status, 'published'))
        .limit(1000)
      
      posts.forEach(post => {
        routes.push(`/community/posts/${post.id}`)
      })
      
      return routes
    }
  },
  
  // ğŸ¤– Robots.txt é…ç½®
  robots: {
    UserAgent: '*',
    Allow: '/',
    Disallow: ['/admin', '/api', '/auth'],
    Sitemap: 'https://knzn.net/sitemap.xml'
  },
  
  // ğŸ“Š ç»“æ„åŒ–æ•°æ®
  schemaOrg: {
    identity: {
      type: 'Organization',
      name: 'KNZN',
      url: 'https://knzn.net',
      logo: 'https://knzn.net/logo.png',
      sameAs: [
        'https://twitter.com/knzn_platform',
        'https://github.com/knzn-platform'
      ]
    }
  }
})
```

### åŠ¨æ€ SEO å…ƒæ•°æ®

```vue
<!-- pages/blueprints/[id].vue -->
<template>
  <div class="blueprint-page">
    <!-- è“å›¾å†…å®¹ -->
  </div>
</template>

<script setup lang="ts">
const route = useRoute()
const blueprintId = route.params.id as string

// ğŸ“Š è·å–è“å›¾æ•°æ®
const { data: blueprint } = await $fetch(`/api/blueprints/${blueprintId}`)

if (!blueprint) {
  throw createError({
    statusCode: 404,
    statusMessage: 'Blueprint not found'
  })
}

// ğŸ” åŠ¨æ€ SEO é…ç½®
useSeoMeta({
  title: `${blueprint.title} - KNZN Blueprint`,
  description: blueprint.description,
  ogTitle: blueprint.title,
  ogDescription: blueprint.description,
  ogImage: blueprint.coverImage,
  ogUrl: `https://knzn.net/blueprints/${blueprintId}`,
  twitterCard: 'summary_large_image',
  twitterTitle: blueprint.title,
  twitterDescription: blueprint.description,
  twitterImage: blueprint.coverImage
})

// ğŸ“Š ç»“æ„åŒ–æ•°æ®
useSchemaOrg([
  {
    '@type': 'Article',
    headline: blueprint.title,
    description: blueprint.description,
    image: blueprint.coverImage,
    author: {
      '@type': 'Organization',
      name: 'KNZN'
    },
    publisher: {
      '@type': 'Organization',
      name: 'KNZN',
      logo: {
        '@type': 'ImageObject',
        url: 'https://knzn.net/logo.png'
      }
    },
    datePublished: blueprint.createdAt,
    dateModified: blueprint.updatedAt
  }
])
</script>
```

### SEO æ€§èƒ½ç›‘æ§

```typescript
// server/api/seo/analytics.get.ts
export default defineEventHandler(async (event) => {
  const admin = await getAdminUser(event)
  if (!admin) {
    throw createError({ statusCode: 403, statusMessage: 'Admin access required' })
  }
  
  try {
    // ğŸ“Š è·å– Google Search Console æ•°æ® (éœ€è¦é…ç½® API)
    const searchConsoleData = await getSearchConsoleData()
    
    // ğŸ“ˆ è·å–é¡µé¢æ€§èƒ½æ•°æ®
    const performanceData = await getPageSpeedData()
    
    // ğŸ” è·å–å…³é”®è¯æ’å
    const keywordRankings = await getKeywordRankings()
    
    return {
      searchConsole: searchConsoleData,
      performance: performanceData,
      keywords: keywordRankings,
      lastUpdated: new Date().toISOString()
    }
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'SEO analytics fetch failed'
    })
  }
})

// ğŸ” å…³é”®è¯æ’åè·Ÿè¸ª
const getKeywordRankings = async () => {
  const keywords = [
    'hardware learning platform',
    'electronics simulation',
    'wokwi tutorials',
    'arduino learning',
    'circuit simulation online',
    'electronics education',
    'hardware engineering course'
  ]
  
  // è¿™é‡Œå¯ä»¥é›†æˆç¬¬ä¸‰æ–¹ SEO API å¦‚ SEMrush, Ahrefs ç­‰
  return keywords.map(keyword => ({
    keyword,
    position: Math.floor(Math.random() * 100) + 1, // æ¨¡æ‹Ÿæ•°æ®
    searchVolume: Math.floor(Math.random() * 10000),
    difficulty: Math.floor(Math.random() * 100)
  }))
}
```

## ğŸ“§ é‚®ä»¶è¥é”€ç³»ç»Ÿ

### é‚®ä»¶æ¨¡æ¿ç®¡ç†

```typescript
// server/utils/email-templates.ts
export const EMAIL_TEMPLATES = {
  // ğŸ‰ æ¬¢è¿ç³»åˆ—é‚®ä»¶
  'welcome-series-1': {
    subject: 'Welcome to KNZN! Your hardware journey starts here ğŸš€',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <div style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding: 40px 20px; text-align: center;">
          <img src="https://knzn.net/logo-white.png" alt="KNZN" style="height: 60px;">
          <h1 style="color: #00ff88; margin: 20px 0;">Welcome to the Future of Hardware Learning!</h1>
        </div>
        
        <div style="padding: 30px 20px;">
          <p style="font-size: 18px; color: #333;">Hi {{name}},</p>
          
          <p>Welcome to KNZN! You've just joined thousands of developers who are mastering hardware engineering through our interactive platform.</p>
          
          <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h3 style="color: #00ff88; margin-top: 0;">ğŸ¯ What's Next?</h3>
            <ul style="padding-left: 20px;">
              <li><strong>Explore the Skill Map</strong> - See your complete learning journey</li>
              <li><strong>Try Your First Simulation</strong> - Start with basic LED circuits</li>
              <li><strong>Join the Community</strong> - Share projects and get help</li>
              <li><strong>Earn Certificates</strong> - Build your professional portfolio</li>
            </ul>
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="https://knzn.net/skill-map" style="background: #00ff88; color: #000; padding: 15px 30px; text-decoration: none; border-radius: 6px; font-weight: bold; display: inline-block;">
              Start Learning Now
            </a>
          </div>
          
          <p>Over the next few days, I'll send you some tips to help you get the most out of KNZN. If you have any questions, just reply to this email!</p>
          
          <p>Happy coding!<br>
          <strong>The KNZN Team</strong></p>
        </div>
        
        <div style="background: #f8f9fa; padding: 20px; text-align: center; font-size: 14px; color: #666;">
          <p>Follow us: 
            <a href="https://twitter.com/knzn_platform">Twitter</a> | 
            <a href="https://github.com/knzn-platform">GitHub</a> | 
            <a href="https://knzn.net/community">Community</a>
          </p>
          <p>
            <a href="{{unsubscribeUrl}}">Unsubscribe</a> | 
            <a href="https://knzn.net/privacy">Privacy Policy</a>
          </p>
        </div>
      </div>
    `
  },
  
  // ğŸ“š å­¦ä¹ è¿›åº¦æé†’
  'progress-reminder': {
    subject: 'Don\'t lose momentum! Continue your hardware journey ğŸ’ª',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #00ff88;">Hi {{name}}, ready to level up?</h2>
        
        <p>I noticed you haven't been active on KNZN for a few days. Don't worry - we all need breaks! But I wanted to remind you of the progress you've made:</p>
        
        <div style="background: #1a1a2e; color: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
          <h3 style="color: #00ff88;">ğŸ“Š Your Progress</h3>
          <ul>
            <li>Level: {{userLevel}}</li>
            <li>XP: {{userXP}}</li>
            <li>Completed Lessons: {{completedLessons}}</li>
            <li>Certificates Earned: {{certificates}}</li>
          </ul>
        </div>
        
        <p>You're doing great! Here's what I recommend for your next session:</p>
        
        <div style="border-left: 4px solid #00ff88; padding-left: 20px; margin: 20px 0;">
          <h4>ğŸ¯ Suggested Next Steps:</h4>
          <p><strong>{{nextLesson}}</strong><br>
          {{nextLessonDescription}}</p>
        </div>
        
        <div style="text-align: center; margin: 30px 0;">
          <a href="https://knzn.net/lesson/{{nextLessonId}}" style="background: #00ff88; color: #000; padding: 15px 30px; text-decoration: none; border-radius: 6px; font-weight: bold;">
            Continue Learning
          </a>
        </div>
        
        <p>Remember: consistency beats intensity. Even 15 minutes a day can make a huge difference!</p>
      </div>
    `
  },
  
  // ğŸ† æˆå°±è§£é”
  'achievement-unlocked': {
    subject: 'ğŸ† Achievement Unlocked: {{achievementName}}!',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; text-align: center;">
        <div style="background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); padding: 40px 20px;">
          <h1 style="font-size: 48px; margin: 0;">ğŸ†</h1>
          <h2 style="color: #000; margin: 10px 0;">Achievement Unlocked!</h2>
          <h3 style="color: #333; margin: 0;">{{achievementName}}</h3>
        </div>
        
        <div style="padding: 30px 20px;">
          <p style="font-size: 18px;">Congratulations {{name}}!</p>
          
          <p>You've just unlocked the <strong>{{achievementName}}</strong> achievement. {{achievementDescription}}</p>
          
          <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 20px 0;">
            <h4>ğŸ Rewards Earned:</h4>
            <ul style="list-style: none; padding: 0;">
              <li>âœ¨ +{{xpReward}} XP</li>
              <li>ğŸ… {{badgeName}} Badge</li>
              {{#if bonusReward}}
              <li>ğŸ‰ {{bonusReward}}</li>
              {{/if}}
            </ul>
          </div>
          
          <div style="text-align: center; margin: 30px 0;">
            <a href="https://knzn.net/profile/achievements" style="background: #00ff88; color: #000; padding: 15px 30px; text-decoration: none; border-radius: 6px; font-weight: bold;">
              View All Achievements
            </a>
          </div>
          
          <p>Keep up the excellent work! What will you unlock next?</p>
        </div>
      </div>
    `
  }
}

// ğŸ“§ è‡ªåŠ¨é‚®ä»¶å‘é€ç³»ç»Ÿ
export const scheduleWelcomeSeries = async (userId: string, email: string, name: string) => {
  const welcomeEmails = [
    { template: 'welcome-series-1', delay: 0 }, // ç«‹å³å‘é€
    { template: 'welcome-series-2', delay: 24 * 60 * 60 * 1000 }, // 1å¤©å
    { template: 'welcome-series-3', delay: 3 * 24 * 60 * 60 * 1000 }, // 3å¤©å
    { template: 'welcome-series-4', delay: 7 * 24 * 60 * 60 * 1000 }  // 7å¤©å
  ]
  
  for (const emailConfig of welcomeEmails) {
    await scheduleEmail({
      userId,
      email,
      template: emailConfig.template,
      data: { name },
      sendAt: new Date(Date.now() + emailConfig.delay)
    })
  }
}

// ğŸ“… é‚®ä»¶è°ƒåº¦ç³»ç»Ÿ
const scheduleEmail = async (emailJob: {
  userId: string
  email: string
  template: string
  data: Record<string, any>
  sendAt: Date
}) => {
  await db.insert(scheduledEmails).values({
    id: nanoid(),
    userId: emailJob.userId,
    email: emailJob.email,
    template: emailJob.template,
    data: JSON.stringify(emailJob.data),
    scheduledFor: emailJob.sendAt,
    status: 'pending',
    createdAt: new Date()
  })
}
```

### é‚®ä»¶è‡ªåŠ¨åŒ–è§¦å‘å™¨

```typescript
// server/api/cron/email-automation.get.ts
export default defineEventHandler(async (event) => {
  // ğŸ” éªŒè¯ Cron è¯·æ±‚
  const authHeader = getHeader(event, 'authorization')
  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
    throw createError({
      statusCode: 401,
      statusMessage: 'Unauthorized'
    })
  }
  
  try {
    let processedEmails = 0
    
    // ğŸ“§ å¤„ç†å¾…å‘é€é‚®ä»¶
    processedEmails += await processScheduledEmails()
    
    // ğŸ“Š å‘é€è¿›åº¦æé†’
    processedEmails += await sendProgressReminders()
    
    // ğŸ† å‘é€æˆå°±é€šçŸ¥
    processedEmails += await sendAchievementNotifications()
    
    // ğŸ’” å‘é€æµå¤±ç”¨æˆ·æŒ½å›é‚®ä»¶
    processedEmails += await sendWinbackEmails()
    
    return {
      success: true,
      processedEmails,
      timestamp: new Date().toISOString()
    }
  } catch (error) {
    console.error('Email automation error:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Email automation failed'
    })
  }
})

// ğŸ“§ å¤„ç†è®¡åˆ’é‚®ä»¶
const processScheduledEmails = async (): Promise<number> => {
  const pendingEmails = await db.select()
    .from(scheduledEmails)
    .where(and(
      eq(scheduledEmails.status, 'pending'),
      lte(scheduledEmails.scheduledFor, new Date())
    ))
    .limit(100)
  
  let sent = 0
  
  for (const email of pendingEmails) {
    try {
      await sendEmail({
        to: email.email,
        template: email.template,
        data: JSON.parse(email.data)
      })
      
      await db.update(scheduledEmails)
        .set({ 
          status: 'sent', 
          sentAt: new Date() 
        })
        .where(eq(scheduledEmails.id, email.id))
      
      sent++
    } catch (error) {
      await db.update(scheduledEmails)
        .set({ 
          status: 'failed', 
          error: error.message 
        })
        .where(eq(scheduledEmails.id, email.id))
    }
  }
  
  return sent
}

// ğŸ“Š å‘é€è¿›åº¦æé†’
const sendProgressReminders = async (): Promise<number> => {
  // æŸ¥æ‰¾ 3 å¤©æœªæ´»è·ƒçš„ç”¨æˆ·
  const inactiveUsers = await db.select({
    id: users.id,
    name: users.name,
    email: users.email,
    level: users.level,
    xp: users.xp
  })
  .from(users)
  .where(and(
    lt(users.lastActiveAt, new Date(Date.now() - 3 * 24 * 60 * 60 * 1000)),
    eq(users.emailNotifications, true)
  ))
  .limit(50)
  
  let sent = 0
  
  for (const user of inactiveUsers) {
    // è·å–ç”¨æˆ·è¿›åº¦
    const userProgress = await getUserProgressSummary(user.id)
    
    await sendEmail({
      to: user.email,
      template: 'progress-reminder',
      data: {
        name: user.name,
        userLevel: user.level,
        userXP: user.xp,
        completedLessons: userProgress.completedLessons,
        certificates: userProgress.certificates,
        nextLesson: userProgress.nextLesson?.title,
        nextLessonDescription: userProgress.nextLesson?.description,
        nextLessonId: userProgress.nextLesson?.id
      }
    })
    
    sent++
  }
  
  return sent
}
```

## ğŸ“ˆ åˆ†æä¸ç›‘æ§

### ç”¨æˆ·è¡Œä¸ºåˆ†æ

```typescript
// server/api/analytics/user-behavior.get.ts
export default defineEventHandler(async (event) => {
  const admin = await getAdminUser(event)
  if (!admin) {
    throw createError({ statusCode: 403, statusMessage: 'Admin access required' })
  }
  
  const timeRange = getQuery(event).range || '30d'
  const startDate = getDateFromRange(timeRange)
  
  try {
    const analytics = {
      // ğŸ‘¥ ç”¨æˆ·ç»Ÿè®¡
      userStats: await getUserStats(startDate),
      
      // ğŸ“š å­¦ä¹ ç»Ÿè®¡
      learningStats: await getLearningStats(startDate),
      
      // ğŸ’° æ”¶å…¥ç»Ÿè®¡
      revenueStats: await getRevenueStats(startDate),
      
      // ğŸ”„ è½¬åŒ–æ¼æ–—
      conversionFunnel: await getConversionFunnel(startDate),
      
      // ğŸ“Š ç”¨æˆ·ç•™å­˜
      retentionCohorts: await getRetentionCohorts(startDate)
    }
    
    return analytics
  } catch (error) {
    throw createError({
      statusCode: 500,
      statusMessage: 'Analytics fetch failed'
    })
  }
})

// ğŸ‘¥ ç”¨æˆ·ç»Ÿè®¡
const getUserStats = async (startDate: Date) => {
  const totalUsers = await db.select({ count: count() }).from(users)
  const newUsers = await db.select({ count: count() })
    .from(users)
    .where(gte(users.createdAt, startDate))
  
  const activeUsers = await db.select({ count: count() })
    .from(users)
    .where(gte(users.lastActiveAt, startDate))
  
  const proUsers = await db.select({ count: count() })
    .from(users)
    .where(eq(users.isPro, true))
  
  return {
    total: totalUsers[0].count,
    new: newUsers[0].count,
    active: activeUsers[0].count,
    pro: proUsers[0].count,
    conversionRate: ((proUsers[0].count / totalUsers[0].count) * 100).toFixed(2)
  }
}

// ğŸ’° æ”¶å…¥ç»Ÿè®¡
const getRevenueStats = async (startDate: Date) => {
  const subscriptions = await db.select({
    price: subscriptions.price,
    currency: subscriptions.currency,
    createdAt: subscriptions.createdAt
  })
  .from(subscriptions)
  .where(and(
    gte(subscriptions.createdAt, startDate),
    eq(subscriptions.status, 'active')
  ))
  
  const totalRevenue = subscriptions.reduce((sum, sub) => sum + sub.price, 0)
  const monthlyRecurring = subscriptions
    .filter(sub => sub.currency === 'USD')
    .reduce((sum, sub) => sum + sub.price, 0)
  
  return {
    totalRevenue,
    monthlyRecurring,
    averageRevenuePerUser: totalRevenue / subscriptions.length || 0,
    subscriptionCount: subscriptions.length
  }
}

// ğŸ”„ è½¬åŒ–æ¼æ–—åˆ†æ
const getConversionFunnel = async (startDate: Date) => {
  const visitors = await db.select({ count: count() })
    .from(pageViews)
    .where(gte(pageViews.createdAt, startDate))
  
  const signups = await db.select({ count: count() })
    .from(users)
    .where(gte(users.createdAt, startDate))
  
  const firstLesson = await db.select({ count: count() })
    .from(progress)
    .where(and(
      gte(progress.createdAt, startDate),
      eq(progress.status, 'completed')
    ))
  
  const conversions = await db.select({ count: count() })
    .from(subscriptions)
    .where(gte(subscriptions.createdAt, startDate))
  
  return {
    visitors: visitors[0].count,
    signups: signups[0].count,
    firstLesson: firstLesson[0].count,
    conversions: conversions[0].count,
    conversionRates: {
      visitorToSignup: ((signups[0].count / visitors[0].count) * 100).toFixed(2),
      signupToFirstLesson: ((firstLesson[0].count / signups[0].count) * 100).toFixed(2),
      firstLessonToConversion: ((conversions[0].count / firstLesson[0].count) * 100).toFixed(2)
    }
  }
}
```

---

**æ–‡æ¡£ç‰ˆæœ¬**: v2.0 - KNZN ä¸“ç”¨ç‰ˆ  
**æœ€åæ›´æ–°**: 2024-12-23  
**é€‚ç”¨é¡¹ç›®**: KNZN ç¡¬ä»¶å­¦ä¹ å¹³å°  
**å•†ä¸šæ¨¡å¼**: SaaS + è”ç›Ÿè¥é”€ + å…¨çƒåˆè§„

è¿™ä»½å•†ä¸šåŒ–æŒ‡å—ä¸“ä¸º KNZN é¡¹ç›®çš„å…¨çƒå¸‚åœºè®¾è®¡ï¼Œç¡®ä¿åœ¨è¿½æ±‚å•†ä¸šæˆåŠŸçš„åŒæ—¶å®Œå…¨ç¬¦åˆ GDPR/CCPA ç­‰æ³•è§„è¦æ±‚ï¼Œå¹¶é€šè¿‡è‡ªåŠ¨åŒ–ç³»ç»Ÿæœ€å¤§åŒ–è¿è¥æ•ˆç‡ã€‚
## ğŸ”’ å®‰å…¨é˜²æŠ¤ç³»ç»Ÿ (BOM æœç´¢é˜²æŠ¤)

### æœç´¢å…³é”®è¯å®‰å…¨æ ¡éªŒ

```typescript
// server/utils/security-sanitizer.ts

// ğŸ”’ æœç´¢å…³é”®è¯å®‰å…¨æ ¡éªŒå™¨
export const sanitizeKeyword = (keyword: string): { 
  sanitized: string; 
  isValid: boolean; 
  violations: string[] 
} => {
  const violations: string[] = []
  
  // ğŸ§¹ åŸºç¡€æ¸…ç†
  let sanitized = keyword.trim()
  
  // ğŸš« é•¿åº¦é™åˆ¶
  if (sanitized.length > 100) {
    sanitized = sanitized.substring(0, 100)
    violations.push('Keyword truncated to 100 characters')
  }
  
  if (sanitized.length < 2) {
    return {
      sanitized: '',
      isValid: false,
      violations: ['Keyword too short (minimum 2 characters)']
    }
  }
  
  // ğŸ” æ­£åˆ™æ ¡éªŒï¼šä»…å…è®¸ä¸­è‹±æ–‡æ•°å­—å’ŒåŸºæœ¬ç¬¦å·
  const allowedPattern = /^[a-zA-Z0-9\u4e00-\u9fa5\s\-_\.]+$/
  if (!allowedPattern.test(sanitized)) {
    violations.push('Invalid characters detected')
    // ç§»é™¤ä¸å…è®¸çš„å­—ç¬¦
    sanitized = sanitized.replace(/[^a-zA-Z0-9\u4e00-\u9fa5\s\-_\.]/g, '')
  }
  
  // ğŸš« XSS é˜²æŠ¤ï¼šæ£€æµ‹è„šæœ¬æ³¨å…¥
  const xssPatterns = [
    /<script[^>]*>.*?<\/script>/gi,
    /javascript:/gi,
    /on\w+\s*=/gi,
    /<iframe[^>]*>/gi,
    /data:text\/html/gi,
    /vbscript:/gi
  ]
  
  for (const pattern of xssPatterns) {
    if (pattern.test(sanitized)) {
      violations.push('Potential XSS attack detected')
      sanitized = sanitized.replace(pattern, '')
    }
  }
  
  // ğŸš« å¼€æ”¾é‡å®šå‘é˜²æŠ¤ï¼šæ£€æµ‹ URL æ¨¡å¼
  const redirectPatterns = [
    /https?:\/\//gi,
    /ftp:\/\//gi,
    /file:\/\//gi,
    /\.\.\/+/g,
    /\/\/+/g
  ]
  
  for (const pattern of redirectPatterns) {
    if (pattern.test(sanitized)) {
      violations.push('Potential open redirect detected')
      sanitized = sanitized.replace(pattern, '')
    }
  }
  
  // ğŸš« SQL æ³¨å…¥é˜²æŠ¤
  const sqlPatterns = [
    /(\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\b)/gi,
    /('|(\\')|(;)|(--)|(\|)|(\*)|(%)|(\+))/g,
    /(\b(OR|AND)\b.*=)/gi
  ]
  
  for (const pattern of sqlPatterns) {
    if (pattern.test(sanitized)) {
      violations.push('Potential SQL injection detected')
      sanitized = sanitized.replace(pattern, '')
    }
  }
  
  // ğŸš« è·¯å¾„éå†é˜²æŠ¤
  const pathTraversalPatterns = [
    /\.\.\//g,
    /\.\.\\+/g,
    /%2e%2e%2f/gi,
    /%2e%2e%5c/gi
  ]
  
  for (const pattern of pathTraversalPatterns) {
    if (pattern.test(sanitized)) {
      violations.push('Path traversal attempt detected')
      sanitized = sanitized.replace(pattern, '')
    }
  }
  
  // ğŸ§¹ æœ€ç»ˆæ¸…ç†
  sanitized = sanitized.trim()
  
  return {
    sanitized,
    isValid: sanitized.length >= 2 && violations.length === 0,
    violations
  }
}

// ğŸ” BOM æœç´¢å®‰å…¨ä¸­é—´ä»¶
export const validateBOMSearch = (searchQuery: string): {
  isValid: boolean;
  sanitizedQuery: string;
  securityReport: {
    violations: string[];
    riskLevel: 'low' | 'medium' | 'high';
    blocked: boolean;
  }
} => {
  const result = sanitizeKeyword(searchQuery)
  
  // ğŸš¨ é£é™©ç­‰çº§è¯„ä¼°
  let riskLevel: 'low' | 'medium' | 'high' = 'low'
  let blocked = false
  
  if (result.violations.length > 0) {
    const highRiskViolations = [
      'Potential XSS attack detected',
      'Potential open redirect detected',
      'Potential SQL injection detected',
      'Path traversal attempt detected'
    ]
    
    const hasHighRisk = result.violations.some(v => 
      highRiskViolations.some(hr => v.includes(hr))
    )
    
    if (hasHighRisk) {
      riskLevel = 'high'
      blocked = true
    } else if (result.violations.length > 2) {
      riskLevel = 'medium'
    }
  }
  
  return {
    isValid: result.isValid && !blocked,
    sanitizedQuery: result.sanitized,
    securityReport: {
      violations: result.violations,
      riskLevel,
      blocked
    }
  }
}
```

### BOM æœç´¢ API å®‰å…¨å®ç°

```typescript
// server/api/bom/search.post.ts
export default defineEventHandler(async (event) => {
  const body = await readBody(event)
  const { query, category, priceRange } = body
  
  // ğŸ”’ å®‰å…¨æ ¡éªŒ
  const securityCheck = validateBOMSearch(query)
  
  if (!securityCheck.isValid) {
    // ğŸ“ è®°å½•å®‰å…¨äº‹ä»¶
    await logSecurityEvent({
      type: 'bom_search_blocked',
      originalQuery: query,
      violations: securityCheck.securityReport.violations,
      riskLevel: securityCheck.securityReport.riskLevel,
      userIP: getClientIP(event),
      userAgent: getHeader(event, 'user-agent'),
      timestamp: new Date()
    })
    
    throw createError({
      statusCode: 400,
      statusMessage: 'Invalid search query',
      data: {
        violations: securityCheck.securityReport.violations,
        riskLevel: securityCheck.securityReport.riskLevel
      }
    })
  }
  
  // âœ… ä½¿ç”¨æ¸…ç†åçš„æŸ¥è¯¢è¿›è¡Œæœç´¢
  const sanitizedQuery = securityCheck.sanitizedQuery
  
  try {
    // ğŸ” æ‰§è¡Œå®‰å…¨çš„ BOM æœç´¢
    const searchResults = await performSecureBOMSearch({
      query: sanitizedQuery,
      category: sanitizeCategory(category),
      priceRange: validatePriceRange(priceRange)
    })
    
    // ğŸ“Š è®°å½•æœç´¢ç»Ÿè®¡
    await recordSearchAnalytics({
      query: sanitizedQuery,
      category,
      resultCount: searchResults.length,
      userIP: getClientIP(event)
    })
    
    return {
      success: true,
      query: sanitizedQuery,
      results: searchResults,
      securityInfo: {
        sanitized: query !== sanitizedQuery,
        violations: securityCheck.securityReport.violations
      }
    }
  } catch (error) {
    console.error('BOM search error:', error)
    throw createError({
      statusCode: 500,
      statusMessage: 'Search failed'
    })
  }
})

// ğŸ” å®‰å…¨çš„ BOM æœç´¢å®ç°
const performSecureBOMSearch = async (params: {
  query: string;
  category?: string;
  priceRange?: { min: number; max: number };
}) => {
  const { query, category, priceRange } = params
  
  // ğŸª å®‰å…¨çš„ä¾›åº”å•† API è°ƒç”¨
  const suppliers = [
    {
      name: 'DigiKey',
      apiUrl: 'https://api.digikey.com/Search/v3/Products/Keyword',
      affiliateId: process.env.DIGIKEY_AFFILIATE_ID
    },
    {
      name: 'Mouser',
      apiUrl: 'https://api.mouser.com/api/v1/search/keyword',
      affiliateId: process.env.MOUSER_AFFILIATE_ID
    }
  ]
  
  const results = []
  
  for (const supplier of suppliers) {
    try {
      // ğŸ”’ æ„å»ºå®‰å…¨çš„ API è¯·æ±‚
      const searchParams = new URLSearchParams({
        keyword: query,
        ...(category && { category }),
        ...(priceRange && { 
          minPrice: priceRange.min.toString(),
          maxPrice: priceRange.max.toString()
        }),
        affiliate: supplier.affiliateId || ''
      })
      
      // ğŸŒ è°ƒç”¨ä¾›åº”å•† API
      const response = await fetch(`${supplier.apiUrl}?${searchParams}`, {
        headers: {
          'User-Agent': 'KNZN-Platform/1.0',
          'Accept': 'application/json'
        },
        timeout: 5000 // 5ç§’è¶…æ—¶
      })
      
      if (response.ok) {
        const data = await response.json()
        
        // ğŸ§¹ æ¸…ç†å’Œæ ‡å‡†åŒ–ç»“æœ
        const cleanResults = sanitizeSearchResults(data, supplier.name)
        results.push(...cleanResults)
      }
    } catch (error) {
      console.error(`${supplier.name} search error:`, error)
      // ç»§ç»­å…¶ä»–ä¾›åº”å•†çš„æœç´¢
    }
  }
  
  // ğŸ”„ å»é‡å’Œæ’åº
  return deduplicateAndSort(results)
}

// ğŸ§¹ æ¸…ç†æœç´¢ç»“æœ
const sanitizeSearchResults = (rawResults: any, supplierName: string) => {
  if (!Array.isArray(rawResults.products)) {
    return []
  }
  
  return rawResults.products.map((product: any) => ({
    id: sanitizeString(product.id || ''),
    name: sanitizeString(product.name || ''),
    description: sanitizeString(product.description || ''),
    price: validatePrice(product.price),
    currency: sanitizeString(product.currency || 'USD'),
    availability: sanitizeString(product.availability || ''),
    supplier: supplierName,
    // ğŸ”— ç”Ÿæˆå®‰å…¨çš„è”ç›Ÿé“¾æ¥
    affiliateUrl: generateSafeAffiliateUrl(product.url, supplierName),
    datasheet: sanitizeUrl(product.datasheet),
    image: sanitizeUrl(product.image),
    specifications: sanitizeSpecifications(product.specifications)
  })).filter(product => product.id && product.name) // è¿‡æ»¤æ— æ•ˆç»“æœ
}

// ğŸ”— ç”Ÿæˆå®‰å…¨çš„è”ç›Ÿé“¾æ¥
const generateSafeAffiliateUrl = (originalUrl: string, supplier: string): string => {
  if (!originalUrl || typeof originalUrl !== 'string') {
    return ''
  }
  
  // ğŸ” éªŒè¯ URL æ ¼å¼
  try {
    const url = new URL(originalUrl)
    
    // ğŸš« ä»…å…è®¸ HTTPS å’Œå·²çŸ¥ä¾›åº”å•†åŸŸå
    const allowedDomains = [
      'digikey.com',
      'mouser.com',
      'element14.com',
      'rs-online.com',
      'aliexpress.com'
    ]
    
    const isAllowedDomain = allowedDomains.some(domain => 
      url.hostname.endsWith(domain)
    )
    
    if (url.protocol !== 'https:' || !isAllowedDomain) {
      return ''
    }
    
    // ğŸ·ï¸ æ·»åŠ è”ç›Ÿæ ‡è¯†
    const affiliateParams = getAffiliateParams(supplier)
    if (affiliateParams) {
      Object.entries(affiliateParams).forEach(([key, value]) => {
        url.searchParams.set(key, value)
      })
    }
    
    return url.toString()
  } catch {
    return ''
  }
}

// ğŸ·ï¸ è·å–è”ç›Ÿå‚æ•°
const getAffiliateParams = (supplier: string): Record<string, string> | null => {
  const affiliateConfig = {
    'DigiKey': {
      'aid': process.env.DIGIKEY_AFFILIATE_ID || '',
      'utm_source': 'knzn',
      'utm_medium': 'affiliate'
    },
    'Mouser': {
      'partnumber': process.env.MOUSER_AFFILIATE_ID || '',
      'utm_source': 'knzn'
    }
  }
  
  return affiliateConfig[supplier] || null
}

// ğŸ“ è®°å½•å®‰å…¨äº‹ä»¶
const logSecurityEvent = async (event: {
  type: string;
  originalQuery: string;
  violations: string[];
  riskLevel: string;
  userIP: string;
  userAgent?: string;
  timestamp: Date;
}) => {
  await db.insert(securityLogs).values({
    id: nanoid(),
    eventType: event.type,
    severity: event.riskLevel,
    details: JSON.stringify({
      originalQuery: event.originalQuery,
      violations: event.violations,
      userAgent: event.userAgent
    }),
    userIP: event.userIP,
    createdAt: event.timestamp
  })
  
  // ğŸš¨ é«˜é£é™©äº‹ä»¶ç«‹å³å‘Šè­¦
  if (event.riskLevel === 'high') {
    await sendSecurityAlert(event)
  }
}

// ğŸš¨ å‘é€å®‰å…¨å‘Šè­¦
const sendSecurityAlert = async (event: any) => {
  await sendEmail({
    to: 'security@knzn.net',
    template: 'security-alert',
    data: {
      eventType: event.type,
      riskLevel: event.riskLevel,
      violations: event.violations,
      userIP: event.userIP,
      timestamp: event.timestamp.toISOString()
    }
  })
}
```

### å‰ç«¯å®‰å…¨æœç´¢ç»„ä»¶

```vue
<!-- components/SecureBOMSearch.vue -->
<template>
  <div class="secure-bom-search">
    <div class="search-container">
      <form @submit.prevent="performSearch" class="search-form">
        <div class="input-group">
          <input
            v-model="searchQuery"
            type="text"
            placeholder="Search for components (e.g., Arduino Uno, resistor 220Î©)"
            class="search-input"
            :class="{ 'error': hasSecurityWarning }"
            maxlength="100"
            @input="validateInput"
          />
          <button 
            type="submit" 
            :disabled="!isValidQuery || searching"
            class="search-btn"
          >
            <Icon v-if="searching" name="loading" class="animate-spin" />
            <Icon v-else name="search" />
            Search
          </button>
        </div>
        
        <!-- ğŸš¨ å®‰å…¨è­¦å‘Š -->
        <div v-if="securityWarning" class="security-warning">
          <Icon name="shield-exclamation" class="text-yellow-500" />
          <span>{{ securityWarning }}</span>
        </div>
        
        <!-- âœ… è¾“å…¥æç¤º -->
        <div class="input-hints">
          <span class="hint">ğŸ’¡ Try: "Arduino Nano", "LED 5mm red", "Capacitor 100uF"</span>
        </div>
      </form>
    </div>
    
    <!-- ğŸ” æœç´¢ç»“æœ -->
    <div v-if="searchResults.length > 0" class="search-results">
      <div class="results-header">
        <h3>Found {{ searchResults.length }} components</h3>
        <div v-if="searchInfo.sanitized" class="sanitization-notice">
          <Icon name="shield-check" class="text-green-500" />
          <span>Search query was automatically cleaned for security</span>
        </div>
      </div>
      
      <div class="results-grid">
        <div 
          v-for="component in searchResults"
          :key="component.id"
          class="component-card"
        >
          <div class="component-image">
            <img 
              :src="component.image || '/images/component-placeholder.png'"
              :alt="component.name"
              loading="lazy"
            />
          </div>
          
          <div class="component-info">
            <h4>{{ component.name }}</h4>
            <p class="description">{{ component.description }}</p>
            
            <div class="component-details">
              <div class="price">
                <span class="amount">{{ component.price }}</span>
                <span class="currency">{{ component.currency }}</span>
              </div>
              <div class="supplier">{{ component.supplier }}</div>
            </div>
            
            <div class="component-actions">
              <a 
                :href="component.affiliateUrl"
                target="_blank"
                rel="noopener noreferrer"
                class="buy-btn"
                @click="trackPurchaseClick(component)"
              >
                <Icon name="external-link" />
                View on {{ component.supplier }}
              </a>
              
              <button 
                @click="addToBOM(component)"
                class="add-btn"
              >
                <Icon name="plus" />
                Add to BOM
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
const searchQuery = ref('')
const searching = ref(false)
const searchResults = ref([])
const securityWarning = ref('')
const hasSecurityWarning = ref(false)
const isValidQuery = ref(false)
const searchInfo = ref({ sanitized: false })

// ğŸ” è¾“å…¥éªŒè¯ (å®¢æˆ·ç«¯é¢„æ£€)
const validateInput = () => {
  const query = searchQuery.value.trim()
  
  // ğŸ§¹ åŸºç¡€éªŒè¯
  isValidQuery.value = query.length >= 2 && query.length <= 100
  
  // ğŸš« ç®€å•çš„å®¢æˆ·ç«¯å®‰å…¨æ£€æŸ¥
  const suspiciousPatterns = [
    /<script/i,
    /javascript:/i,
    /on\w+=/i,
    /https?:\/\//i
  ]
  
  const hasSuspiciousContent = suspiciousPatterns.some(pattern => 
    pattern.test(query)
  )
  
  if (hasSuspiciousContent) {
    securityWarning.value = 'Invalid characters detected. Please use only component names and specifications.'
    hasSecurityWarning.value = true
    isValidQuery.value = false
  } else {
    securityWarning.value = ''
    hasSecurityWarning.value = false
  }
}

// ğŸ” æ‰§è¡Œæœç´¢
const performSearch = async () => {
  if (!isValidQuery.value || searching.value) return
  
  searching.value = true
  searchResults.value = []
  
  try {
    const response = await $fetch('/api/bom/search', {
      method: 'POST',
      body: {
        query: searchQuery.value.trim(),
        category: 'all'
      }
    })
    
    if (response.success) {
      searchResults.value = response.results
      searchInfo.value = response.securityInfo
      
      // ğŸ“Š è®°å½•æœç´¢äº‹ä»¶
      trackSearchEvent(response.query, response.results.length)
    }
  } catch (error) {
    console.error('Search error:', error)
    
    if (error.data?.violations) {
      securityWarning.value = 'Search blocked for security reasons. Please refine your query.'
      hasSecurityWarning.value = true
    } else {
      alert('Search failed. Please try again.')
    }
  } finally {
    searching.value = false
  }
}

// ğŸ“Š è·Ÿè¸ªæœç´¢äº‹ä»¶
const trackSearchEvent = (query: string, resultCount: number) => {
  // å‘é€åˆ†æäº‹ä»¶åˆ°åç«¯
  $fetch('/api/analytics/search', {
    method: 'POST',
    body: {
      query,
      resultCount,
      timestamp: new Date().toISOString()
    }
  }).catch(() => {
    // é™é»˜å¤±è´¥ï¼Œä¸å½±å“ç”¨æˆ·ä½“éªŒ
  })
}

// ğŸ›’ æ·»åŠ åˆ° BOM
const addToBOM = (component: any) => {
  // å®ç°æ·»åŠ åˆ° BOM é€»è¾‘
  console.log('Adding to BOM:', component)
}

// ğŸ“Š è·Ÿè¸ªè´­ä¹°ç‚¹å‡»
const trackPurchaseClick = (component: any) => {
  // è·Ÿè¸ªè”ç›Ÿé“¾æ¥ç‚¹å‡»
  $fetch('/api/analytics/affiliate-click', {
    method: 'POST',
    body: {
      componentId: component.id,
      supplier: component.supplier,
      price: component.price
    }
  }).catch(() => {
    // é™é»˜å¤±è´¥
  })
}
</script>
```